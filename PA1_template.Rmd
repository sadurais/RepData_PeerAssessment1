---
title: "Reproducible Research: Peer Assessment 1"
author: "Sathish Duraisamy"
date: "January 18, 2015"
output: 
  html_document:
    keep_md: true
---

## Introduction


## Loading and preprocessing the data
The data is loaded from the 'activity.csv' file from current directory into 
a data frame. A quick 'summary' and 'str' functions on this data frame show 
that the 'interval' variable needs to be reformatted correctly. The following
function reads the data, adds a new variable 'int_mins' to capture the 
interval as numerical minutes.

```{r echo=TRUE, eval=TRUE}
library(stringr)
library(ggplot2)
library(scales)
library(stringr)


# Reads the activity.csv file, cleans up data,
# and returns a tidy data frame with imputed values
# for NA values of 'steps'
readData <- function(sanitizeAndImpute=TRUE) {
    
    zipFile <- "activity.zip"
    csvFile <- "activity.csv"
    if (!file.exists(csvFile)) {
        if (file.exists(zipFile)) {
            unzip(zipFile, exdir = ".")
        } else {
            stop(paste("Required data file ", zipFile, " is missing", sep=""))
        }
    }
    
    if (!file.exists(csvFile)) {
        stop(paste("Required csv file ", csvFile, " is missing", sep=""))
    }
    
    df <- read.csv(csvFile, header=TRUE,
                         colClasses=c("numeric", "Date", "integer"))
    set.seed(121212)

    if (!sanitizeAndImpute) return(df)
    
    # Add a variable 'int_mins' to our data frame,
    # reformatting the 'interval' as numerical minutes *correctly*
    int_str <- sprintf("%04d", df$interval)
    hours <- as.integer(str_sub(int_str, 1, 2))
    mins <- as.integer(str_sub(int_str, 3, 4))
    df$int_mins <-  hours * 60 + mins

    # Add a factor variable 'day_type' to our data frame,
    # to track weekdays vs weekends
    df$day_type <- ifelse(weekdays(df$date) %in%
                            c("Sunday", "Saturday"), "weekend", "weekday")
    df$day_type <- as.factor(df$day_type)

    # Impute NA values in 'steps' with the mean-step-per-interval value
    # (calculated across all days of each unique interval). This is better
    # than using per-day mean because many samples are considered and the
    # bias this "overall" mean introduces must be minimal
    avg_steps_per_int <- tapply(df$steps, df$int_mins, mean, na.rm=T)
    df_int <- data.frame(avg_steps = avg_steps_per_int,
                         interval = as.numeric(names(avg_steps_per_int)))
    na_rows <- which(is.na(df$steps))
    for (row in na_rows) {
        intvl <- df$int_mins[row]
        df$steps[row] <- df_int$avg_steps[df_int$interval==intvl]
    }

    df
}
```

```{r echo=TRUE, eval=TRUE}
# Handy function to convert a numerical minutes to HH:MM formated string
minutesToHHMM <- function(mins) {
    hour <- trunc(mins/60)
    min  <- mins %% 60
    return(sprintf("%02d:%02d", hour, min))
}
```


## What is mean total number of steps taken per day?

```{r echo=TRUE, eval=TRUE}
# ---------------------------------------------------------------
# Question 1:  What is mean total number of steps taken per day?
# For this part of the assignment, you can ignore the missing values in the dataset.
library(lattice)

df <- readData(sanitizeAndImpute=FALSE)
df <- df[complete.cases(df), ]  # Throw away NA values

tot_steps_per_day <- tapply(df$steps, df$date, sum)

#Calculate and report the mean and median total number of steps taken per day
summary(tot_steps_per_day)[3:4]  # Median and Mean

# Make a histogram of the total number of steps taken each day.
histogram(tot_steps_per_day, xlab="Total Steps per day",
          ylab="Frequency (ie. Percent of Total)")
# ---------------------------------------------------------------
```
The Median and Mean of the total steps taken per day are: 10760 and 10770 
respectively as shown by the 'summary' output above.


## What is the average daily activity pattern?

```{r echo=TRUE}
library(stringr)
library(ggplot2)
library(scales)
library(stringr)

act <- readData(sanitizeAndImpute=TRUE)

# Now that the NA values in 'steps' are imputed with mean values,
# lets recalculate the mean/intvl
avg_steps_per_int <- tapply(act$steps, act$int_mins, mean)
int_mins = as.numeric(names(avg_steps_per_int))
# We use a dummy-date 2000/01/01 00:00:01 as the 'start' of all our
# time-intervals. While plotting the x-asix, we'll hid this date part
# and show only the time-part. Since ISOdate() creates
dummy_date <- ISOdate(2000, 1, 1, 0, 0, 1, tz="")
df <- data.frame(steps_pi = avg_steps_per_int,
                 int_mins = int_mins,
                 int_tm   = dummy_date + (int_mins * 60),
                 int_str  = minutesToHHMM(int_mins))

ggplot(df, aes(int_tm, steps_pi)) +
    geom_line() +
    scale_x_datetime(labels = date_format(format="%H:%M"), breaks = "2 hours") +
    xlab("Time Interval of day") +
    ylab("Mean Steps per time interval, across all days")

#Which 5-minute interval, on average across all the days in the dataset,
#contains the maximum number of steps?
max_row <- df$steps_pi == max(df$steps_pi)
result <- df[max_row, c("steps_pi", "int_str")]
result
```

As can be seen from the plot and also from the result output above, the
maximum mean steps per interval (measured across all day) is 206 steps
and the time interval is 08:35 AM.
The plot also shows overall activity between 6:00 AM to 9:00 PM and
less activiy at the rest of the hours, understandably the nap time.




## Imputing missing values
For imputing the NA values of 'steps' variable in our data set, we will 
use the strategy of filling them with the mean number of steps (measured
per interval, across all days). This is done within the readData() function
listed above.

The specific code that does this imputation:
```{r, echo=TRUE, eval=FALSE}
    avg_steps_per_int <- tapply(df$steps, df$int_mins, mean, na.rm=T)
    df_int <- data.frame(avg_steps = avg_steps_per_int,
                         interval = as.numeric(names(avg_steps_per_int)))
    na_rows <- which(is.na(df$steps))
    for (row in na_rows) {
        intvl <- df$int_mins[row]
        df$steps[row] <- df_int$avg_steps[df_int$interval==intvl]
    }
```


## Are there differences in activity patterns between weekdays and weekends?
```{r echo=TRUE}
library(stringr)
library(ggplot2)
library(scales)
library(stringr)

act <- readData(sanitizeAndImpute=TRUE)
weekday_rows <- act$day_type == "weekday"
act_wd <- act[weekday_rows, ]
act_we <- act[!weekday_rows, ]

group_by_interval <- function(act) {

    # Now that the NA values in 'steps' are imputed with mean values,
    # lets recalculate the mean/intvl
    avg_steps_per_int <- tapply(act$steps, act$int_mins, mean)
    int_mins = as.numeric(names(avg_steps_per_int))
    # We use a dummy-date 2000/01/01 00:00:01 as the 'start' of all our
    # time-intervals. While plotting the x-asix, we'll hid this date part
    # and show only the time-part. Since ISOdate() creates
    dummy_date <- ISOdate(2000, 1, 1, 0, 0, 1, tz="")
    df <- data.frame(steps_pi = avg_steps_per_int,
                 int_mins = int_mins,
                 int_tm   = dummy_date + (int_mins * 60),
                 int_str  = minutesToHHMM(int_mins))
    df
}

df <- group_by_interval(act_wd); df$day_type <- "weekday"
result1 <- df[df$steps_pi == max(df$steps_pi), c("steps_pi", "int_str")]
df2 <- group_by_interval(act_we); df2$day_type <- "weekend"
result2 <- df2[df2$steps_pi == max(df2$steps_pi), c("steps_pi", "int_str")]

df <- rbind(df, df2)

ggplot(df, aes(int_tm, steps_pi)) +
    geom_line(color="blue") +
    facet_wrap(~day_type, ncol=1) +
    scale_x_datetime(labels = date_format(format="%H:%M"), breaks = "2 hours") +
    xlab("Time Interval of day") +
    ylab("Mean Steps per time interval, across all days")

#Which 5-minute interval, on average across all the days in the dataset,
#contains the maximum number of steps?
print("Max mean steps/interval and the interval for weekdays: ")
result1

print("Max mean steps/interval and the interval for weekdends: ")
result2

```